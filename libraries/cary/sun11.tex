\documentclass[twoside,11pt,nolof]{starlink}

% ? Specify used packages
% ? End of specify used packages



% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\stardocnumber      {11.5}
\stardocauthors     {R.F. Warren-Smith \& D.S. Berry}
\stardocdate        {19th July 2012}
\stardoctitle       {ARY\\[\latex{2.5ex}]
                                A Subroutine Library for Accessing\\
                                ARRAY Data Structures}
\stardocversion     {Version 1.4}
\stardocmanual      {Reference Manual}
\stardocabstract  {%
The ARY library is a set of routines for accessing Starlink ARRAY data
structures built using the Hierarchical Data System (HDS).
}
% -----------------------------------------------------------------------------
% ? Document specific \providecommand or \newenvironment commands.

\providecommand{\noteroutine}[2]{\textbf{#1}\hspace*{\fill}\nopagebreak \\
                             \hspace*{3em}\emph{#2}\hspace*{\fill}\par}

% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\begin{document}
\scfrontmatter

% ? Main text

\section{\xlabel{introduction}Introduction}
\label{introduction}

This is a preliminary document describing a set of routines for accessing
Starlink ARRAY data structures built using the Hierarchical Data System HDS
(\xref{SUN/92}{sun92}{}).  Details of these structures and the design
philosophy behind them can be found in \xref{SGP/38}{sgp38}{}, although
familiarity with that document is not necessarily required in order to
use the routines described here.

This document currently lacks a descriptive section outlining the
philosophy behind the use of the ARY\_ routines.  It is nevertheless
being made available in this form because the ARY\_ system constitutes
an essential sub-component of the NDF\_ system, which contains routines
for accessing Starlink NDF (N-Dimensional Data Format) structures.
These NDF\_ routines are described in \xref{SUN/33}{sun33}{}.

The most likely reason for needing to use the ARY\_ routines directly at
present is for accessing ARRAY structures stored in NDF extensions.
Since most ARY\_ routines closely resemble the equivalent NDF\_ routine,
\xref{SUN/33}{sun33}{} should initially form an adequate introduction to
their use, in conjunction with the detailed routine descriptions contained in
Appendix~\ref{ss:routinedescriptions} of this document.



\section{\xlabel{array_storage_forms}Array Storage Forms}
\label{array_storage_forms}

Note that at present, the ARY\_ system provides full support only for the
``primitive'' and ``simple'' forms of the ARRAY data structure.

Some support is also provided for two additional forms:

\begin{description}
\item[SCALED] - the ``scaled'' form described in SGP/38. This form is the
same as the ``simple'' form except that two
extra scalar values are included that describe a linear scaling from the
stored array values to the data values of interest to an external user.
These two scalars are referred to as SCALE and ZERO. The external
(unscaled) data values are derived from the stored (scaled) data values
as follows:

unscaled\ =\ SCALE*scaled\ +\ ZERO

\item[DELTA] - this form is not currently described in SGP/38. Delta form
provides a lossless compression scheme designed for arrays of integers in
which there is at least one pixel axis along which the array value changes
only slowly. For further details, see \S\ref{ss:deltaform}.

\end{description}

The following points should be noted:

\begin{enumerate}

\item Scaled and delta arrays are ``read-only''. An error will be reported if
an attempt is made to map a scaled or delta array for WRITE or UPDATE
access. When mapped for READ access, the pointer returned by ARY\_MAP
provides access to the \emph{original} data values - that is, the mapped
values are the result of (for scaled arrays) applying the scale and zero
terms to the stored values, or (for delta arrays) uncompressing the
compressed values.

Currently, the internal stored (i.e. scaled or compressed) data values
cannot be accessed directly.

\item The result of copying a scaled or delta array (using ARY\_COPY) will be
an equivalent simple array.

\item Scaled and delta arrays cannot be created directly. Instead, a simple
array must first be created (using ARY\_NEW), and this can then be converted
to a scaled or delta array as follows:

\begin{description}

\item[SCALED] - storing scale and zero values in the simple array using
ARY\_PTSZ<T>. A typical program would create a simple array, map it for
write access, store the scaled data values in the mapped simple array,
unmap the array, and then associate scale and zero values with the array,
thus converting it to a scaled array.

\item[DELTA] - copying the simple array using ARY\_DELTA. The copy will
be a compressed array stored in delta form. A typical program would create
a simple array, map it for write access, store the uncompressed data
values in the mapped simple array, unmap the array, and then copy it using
ARY\_DELTA. The original simple array could then be deleted if it is no
longer needed.

\end{description}

\item Scaled and delta arrays cannot have complex data types. An error will be
reported if an attempt is made to to import an HDS structure describing a
complex scaled or delta array, or to use ARY\_PTSZ<T> or ARY\_DELTA on an
array with complex data values.

\item When applied to a scaled or delta array, the ARY\_TYPE and ARY\_FTYPE
routines return the data type of the external (i.e. unscaled or uncompressed)
values. In practice, this means that for a scaled array they return the data
type of the SCALE and ZERO constants, rather than the data type of the array
holding the stored (scaled) data values. For a delta array they return
the data type of the original uncompressed values.

\end{enumerate}

\subsection{\xlabel{ddelta_form}\label{ss:deltaform}Delta Compressed Array Form}

The DELTA storage form provides lossless compression for integer arrays.
It uses two methods to achieve compression:

\begin{itemize}

\item Differences between adjacent data values are stored, rather than
the full data values themselves. For many forms of astronomical data, the
differences between adjacent data values have a much smaller range than
the data values themselves. This means that they can be represented in
fewer bits. For instance, if the data values are \_INTEGER, then the
differences between adjacent values may fit into the range of a \_WORD
(-32767 to +32767) or even a \_BYTE (-127 to +127). This use of a shorter
data type usually provides the majority of the compression. However, it is not
necessary for all differences to be small - if the difference between two
adjacent data values is too large for the compressed data type, the
second of the two data values will be stored explicitly using the full data
type of the original uncompressed data. Obviously, the more values that
need to be stored in full in this way, the lower will be the compression.

In the above description, the term ``adjacent'' means ``adjacent along a
specified pixel axis''. The pixel axis along which differences are taken
is referred to as the ``compression axis''. It may be specified
explicitly by the calling application when ARY\_DELTA is called, or it
may be left unspecified in which case ARY\_DELTA will choose the axis that
gives the best compression.

\item If the uncompressed array contains runs of more than three identical
values along the compression axis, then the run of identical values is
replaced by a single value (stored in full, not as a difference) and a
repetition count.

\end{itemize}

\subsubsection{Creating a Delta Array}

To create a DELTA array, first store the uncompressed integer values in a
simple array, and then copy the array using ARY\_DELTA. The copy produced
by ARY\_DELTA will be stored in DELTA form.

Arrays of floating point values may be compressed by first storing the
floating point values in a SCALED array, and then using ARY\_DELTA to
create a delta compressed copy of the scaled array. Note, the scaled
array must use an integer data type to store the internal (i.e. scaled)
values. The use of the scaled array means that the compression is not
lossless, since some information will have been lost in scaling the
floating point values into integers.

\subsubsection{The HDS Structure of a Delta Array}
The HDS structure of a DELTA array is similar to the SIMPLE array,
in that it will contain VARIANT, DATA and ORIGIN components. In
addition they can contain SCALE and ZERO terms, which, if present,
are used to scale the uncompressed integers as in a SCALED array.
Uncompression happens first, producing an array of uncompressed
integers, which are then unscaled if required using SCALE and ZERO to
produce the final uncompressed, unscaled, array.

DELTA arrays cannot be used to hold complex values and so no
IMAGINARY\_DATA component will be present. Also, DELTA arrays have an
implicit value of .TRUE. for their bad pixel flags, and so no BAD\_PIXEL
component will be present in the HDS structure.

Information is stored within a DELTA array that allows sub-sections of
the compressed array to be uncompressed without needing to uncompress the
whole array.

A DELTA array is stored in an HDS structure with type DELTA\_ARRAY, and
contains the following components:

\begin{description}

\item[DATA] - This is a one-dimensional integer array holding the differences
between adjacent uncompressed integer data values along the compression
axis. Its data type will be eother \_INTEGER, \_WORD or \_BYTE and is
specified when ARY\_DELTA is called to create the array. A few integer
values (all near the maximum value allowed by the data type) are reserved
for use as flags to indicate one of the following conditions (where
``MAX'' represents the largest positive integer value that can be
represented using the data type of the DATA array):

\begin{itemize}

\item The value MAX is reserved to indicate that the next element of the
uncompressed array is good, but could not be expressed as a difference from
the previous element because the difference would not fit into the
available data range of the DATA array. Instead, the full uncompressed value
is stored in the next element of the VALUE array.

\item The value (MAX-1) is reserved to indicate that the next element of
the uncompressed array is good and is exactly equal to the following (N-1)
elements. The full uncompressed value is stored in the next element of the
VALUE array. The value of N is stored in the next element of the REPEAT array.

\item The value (MAX-2) is reserved to indicate that the next element of
the uncompressed array is bad, as are the following (N-1) elements. The full
uncompressed value of the next good value following the bad values is stored
in the next element of the VALUE array. The value of N is stored in the next
element of the REPEAT array.

\item The value (MAX-3) is reserved to indicate that the next element of
the uncompressed array is bad, but the following element is good and its
full uncompressed value is stored in the next element of the VALUE array.

\item The value (MAX-4) is reserved to indicate that the next N elements of
the uncompressed array are good but cannot be expressed as differences from
the previous element because the differences would not fit into the available
data range of the DATA array. Instead, the full uncompressed values are
stored in the next N elements of the VALUE array. The value of N is
stored in the next element of the REPEAT array.

\item Any other value is taken to be (NEXT - PREVIOUS) - the difference
between the next uncompressed value and the previous uncompressed value.

\end{itemize}

Notes:

\begin{enumerate}

\item The ``available data range'' in DATA is reduced to leave room for the
above flags.

\item The first element in each row of pixels parallel to the compression
axis is always represented using one of these flag values. This allows
each row of pixel values to be uncompressed without reference to any
earlier values.

\item Repeated runs of good or bad value are always contained within a single
row of pixels parallel to the compression axis. Runs of repeated values
that cross the boundary between adjacent rows are split into two repeated
runs - one for each row.

\end{enumerate}

\item[FIRST\_DATA] - This is an \_INTEGER array with (NDIM-1) axes which
have the same order and size as the axes of the uncompressed array, but
omitting the compression axis (NDIM is the number of axes in the
uncompressed array). It holds the zero-based index into the DATA array at
which the first element of the corresponding row of values is stored.

For instance, if the uncompressed array is a cube with bounds
(1:10,1:5,1:7), and the compression axis is axis number 2, then the
FIRST\_DATA array will be two-dimensional with bounds (1:10,1:7). Element
(2,3) of this array (for instance) will hold the integer index of the
DATA array element that gives the full value for pixel (2,1,3) in the
uncompressed array. Elements (2,2,3), (2,3,3), (2,4,3) and (2,5,3) of the
uncompressed array are then derived from the following values in the DATA
array.

\item[FIRST\_REPEAT] - This is an array with the same shape as
the FIRST\_DATA array. It holds the zero-based index of the first value
of the REPEAT array to be used whilst uncompressing the corresponding
row of pixels. This component will only be present in the DELTA\_ARRAY
structure if the REPEAT component is present. The data type of this array
will be one of \_INTEGER, \_UWORD or \_UBYTE, depending on the largest value
stored in it.

\item[FIRST\_VALUE] - This is an array with the same shape as
the FIRST\_DATA array. It holds the zero-based index of the first value
of the VALUE array to be used whilst uncompressing the corresponding
row of pixels. The data type of this array will be one of \_INTEGER,
\_UWORD or \_UBYTE, depending on the largest value stored in it.

\item[ORIGIN] - A one-dimensional \_INTEGER array holding the pixel indices
of the first element of the uncompressed array. This component is optional
- an origin of (1,1,1...) is assumed if the component is not present in the
DELTA\_ARRAY structure.

\item[REPEAT] - A one-dimensional \_INTEGER array holding the number of
repetitions for each value associated with an occurrence of (MAX-1),
(MAX-2) or (MAX-4) in the DATA array. The data type of this array will be
one of \_INTEGER, \_UWORD or \_UBYTE, depending on the largest value stored in
it. This array will not be present if there are no runs in the uncompressed
data array.

\item[SCALE] - An optional component giving a scale factor to apply to the
uncompressed integer values. It can be of any data type. If present the
uncompressed array is treated like a SCALED array. In particular, the
data type of the uncompressed array will be the same as the data type of
the SCALE component, if present. If not present, the data type of the
uncompressed array is given by the data type of the VALUE array.

\item[VALUE] - A one-dimensional array with the same data type as the
uncompressed array (\_INTEGER, \_WORD, \_UWORD, \_BYTE or \_UBYTE) prior to
scaling by SCALE and ZERO. It holds full uncompressed integer values for
the elements that are flagged with any of the special values listed under
``DATA'' above. Note, if SCALE and ZERO components are present in the
DELTA array, the VALUE array holds internal scaled values, rather than
external unscaled values.

\item[VARIANT] - The storage form of the array. This will always be set to
``DELTA''.

\item[ZAXIS] - A scalar \_INTEGER value giving the index of the ecompression
axis - that is, the pixel axis index within the uncompressed array along
which differences were taken. Care should be taken in the choice of ZAXIS
since it can affect the degree of compression achieved. If ZAXIS is not
specified when compressing an array, it defaults to the axis that gives the
greatest compression. Note, the ZAXIS value is one-based, not zero-based.

\item[ZDIM] - A scalar \_INTEGER holding the length of the compression axis
within the uncompressed array. The other dimensions of the uncompressed array
are given by the shape of the FIRST\_DATA array.

\item[ZERO] - An optional component giving a zero offset to add to the
uncompressed integer values. It can be of any data type. If present the
uncompressed array is treated like a SCALED array.

\item[ZRATIO] - A scalar \_REAL holding the compression factor - that is, the
ratio of the uncompressed array size to the compressed array size. This
is approximate as it does not include the effects of the metadata needed
to describe the extra components of a DELTA array (i.e. the space needed
to hold the HDS component names, types, dimensions, etc).

\end{description}

\section{\xlabel{compiling_and_linking}Compiling and Linking}
\label{compiling_and_linking}

Before compiling or linking applications which call ARY\_ routines, you
should first ``log in'' for software development using these routines.
This is done using the \texttt{ary\_dev} command.

\begin{terminalv}
% ary_dev
\end{terminalv}

This will generate links to the ARY include files required for
programming (note that this is only necessary if you reference ARY\_
system include files, or call ARY\_ routines explicitly in your
application).

ADAM applications which call ARY\_ routines may be linked with the link
script \mbox{ary\_link\_adam}, which should be specified on the linker
command line.  For example, to compile and link an application called
\texttt{adamprog} using the \texttt{alink} command, the following might be
used:

\begin{terminalv}
% alink adamprog.f -o adamprog `ary_link_adam`
\end{terminalv}

A ``stand-alone'' (\emph{i.e.} non-ADAM) version of the ARY\_ system is
also available and should be used by those applications which do not
use ADAM facilities.  This version may be obtained by specifying the
options file \mbox{ary\_link} on the linker command line.  For example,
to compile and link a stand-alone application called \texttt{prog}, the
following might be used:

\begin{terminalv}
% f77 -O prog.f -o prog `ary_link`
\end{terminalv}

Both versions of the ARY\_ system contain the same set of user-callable
routines.

\newpage
\appendix

\section{\xlabel{alphabetical_list_of_routines}Alphabetical list of Routines}
\label{alphabetical_list_of_routines}

\noteroutine{ARY\_ANNUL( IARY, STATUS )}
            {Annul an array identifier}
\noteroutine{ARY\_BAD( IARY, CHECK, BAD, STATUS )}
            {Determine if an array may contain bad pixels}
\noteroutine{ARY\_BASE( IARY1, IARY2, STATUS )}
            {Obtain an identifier for a base array}
\noteroutine{ARY\_BOUND( IARY, NDIMX, LBND, UBND, NDIM, STATUS )}
            {Enquire the pixel-index bounds of an array}
\noteroutine{ARY\_CLONE( IARY1, IARY2, STATUS )}
            {Clone an array identifier}
\noteroutine{ARY\_CMPLX( IARY, CMPLX, STATUS )}
            {Determine whether an array holds complex values}
\noteroutine{ARY\_COPY( IARY1, PLACE, IARY2, STATUS )}
            {Copy an array to a new location}
\noteroutine{ARY\_DELET( IARY, STATUS )}
            {Delete an array}
\noteroutine{ARY\_DIM( IARY, NDIMX, DIM, NDIM, STATUS )}
            {Enquire the dimension sizes of an array}
\noteroutine{ARY\_DUPE( IARY1, PLACE, IARY2, STATUS )}
            {Duplicate an array}
\noteroutine{ARY\_FIND( LOC, NAME, IARY, STATUS )}
            {Find an array in an HDS structure and import it into the ARY\_ system}
\noteroutine{ARY\_FORM( IARY, FORM, STATUS )}
            {Obtain the storage form of an array}
\noteroutine{ARY\_FTYPE( IARY, FTYPE, STATUS )}
            {Obtain the full data type of an array}
\noteroutine{ARY\_GTSZx( IARY, SCALE, ZERO, STATUS )}
            {Get the scale and zero values for a scaled array}
\noteroutine{ARY\_IMPRT( LOC, IARY, STATUS )}
            {Import an array into the ARY\_ system from HDS}
\noteroutine{ARY\_ISACC( IARY, ACCESS, ISACC, STATUS )}
            {Determine whether a specified type of array access is available}
\noteroutine{ARY\_ISBAS( IARY, BASE, STATUS )}
            {Enquire if an array is a base array}
\noteroutine{ARY\_ISMAP( IARY, MAPPED, STATUS )}
            {Determine if an array is currently mapped}
\noteroutine{ARY\_ISTMP( IARY, TEMP, STATUS )}
            {Determine if an array is temporary}
\noteroutine{ARY\_MAP( IARY, TYPE, MMOD, PNTR, EL, STATUS )}
            {Obtain mapped access to an array}
\noteroutine{ARY\_MAPZ( IARY, TYPE, MMOD, RPNTR, IPNTR, EL, STATUS )}
            {Obtain complex mapped access to an array}
\noteroutine{ARY\_MSG( TOKEN, IARY )}
            {Assign the name of an array to a message token}
\noteroutine{ARY\_NDIM( IARY, NDIM, STATUS )}
            {Enquire the dimensionality of an array}
\noteroutine{ARY\_NEW( FTYPE, NDIM, LBND, UBND, PLACE, IARY, STATUS )}
            {Create a new simple array}
\noteroutine{ARY\_NEWP( FTYPE, NDIM, UBND, PLACE, IARY, STATUS )}
            {Create a new primitive array}
\noteroutine{ARY\_NOACC( ACCESS, IARY, STATUS )}
            {Disable a specified type of access to an array}
\noteroutine{ARY\_OFFS( IARY1, IARY2, MXOFFS, OFFS, STATUS )}
            {Obtain the pixel offset between two arrays}
\noteroutine{ARY\_PLACE( LOC, NAME, PLACE, STATUS )}
            {Obtain an array placeholder}
\noteroutine{ARY\_PTSZx( IARY, SCALE, ZERO, STATUS )}
            {Set new scale and zero values for a scaled array}
\noteroutine{ARY\_RESET( IARY, STATUS )}
            {Reset an array to an undefined state}
\noteroutine{ARY\_SAME( IARY1, IARY2, SAME, ISECT, STATUS )}
            {Enquire if two arrays are part of the same base array}
\noteroutine{ARY\_SBAD( BAD, IARY, STATUS )}
            {Set the bad-pixel flag for an array}
\noteroutine{ARY\_SBND( NDIM, LBND, UBND, IARY, STATUS )}
            {Set new pixel-index bounds for an array}
\noteroutine{ARY\_SCTYP( IARY, TYPE, STATUS )}
            {Obtain the numeric type of a scaled array}
\noteroutine{ARY\_SECT( IARY1, NDIM, LBND, UBND, IARY2, STATUS )}
            {Create an array section}
\noteroutine{ARY\_SHIFT( NSHIFT, SHIFT, IARY, STATUS )}
            {Apply pixel-index shifts to an array}
\noteroutine{ARY\_SIZE( IARY, NPIX, STATUS )}
            {Determine the size of an array}
\noteroutine{ARY\_SSECT( IARY1, IARY2, IARY3, STATUS )}
            {Produce a similar array section to an existing one}
\noteroutine{ARY\_STATE( IARY, STATE, STATUS )}
            {Determine the state of an array (defined or undefined)}
\noteroutine{ARY\_STYPE( FTYPE, IARY, STATUS )}
            {Set a new type for an array}
\noteroutine{ARY\_TEMP( PLACE, STATUS )}
            {Obtain a placeholder for a temporary array}
\noteroutine{ARY\_TRACE( NEWFLG, OLDFLG )}
            {Set the internal ARY\_ system error-tracing flag}
\noteroutine{ARY\_TYPE( IARY, TYPE, STATUS )}
            {Obtain the numeric type of an array}
\noteroutine{ARY\_UNMAP( IARY, STATUS )}
            {Unmap an array}
\noteroutine{ARY\_VALID( IARY, VALID, STATUS )}
            {Determine whether an array identifier is valid}
\noteroutine{ARY\_VERFY( IARY, STATUS )}
            {Verify that an array's data structure is correctly constructed}


\newpage
\section{\xlabel{classified_list_of_routines}Classified list of Routines}
\label{classified_list_of_routines}


\subsection{\xlabel{access_to_existing_arrays}Access to Existing Arrays}
\label{access_to_existing_arrays}

\noteroutine{ARY\_FIND( LOC, NAME, IARY, STATUS )}
            {Find an array in an HDS structure and import it into the ARY\_ system}
\noteroutine{ARY\_IMPRT( LOC, IARY, STATUS )}
            {Import an array into the ARY\_ system from HDS}


\subsection{\xlabel{enquiring_array_attributes}Enquiring Array Attributes}
\label{enquiring_array_attributes}

\noteroutine{ARY\_BAD( IARY, CHECK, BAD, STATUS )}
            {Determine if an array may contain bad pixels}
\noteroutine{ARY\_BOUND( IARY, NDIMX, LBND, UBND, NDIM, STATUS )}
            {Enquire the pixel-index bounds of an array}
\noteroutine{ARY\_CMPLX( IARY, CMPLX, STATUS )}
            {Determine whether an array holds complex values}
\noteroutine{ARY\_DIM( IARY, NDIMX, DIM, NDIM, STATUS )}
            {Enquire the dimension sizes of an array}
\noteroutine{ARY\_FORM( IARY, FORM, STATUS )}
            {Obtain the storage form of an array}
\noteroutine{ARY\_FTYPE( IARY, FTYPE, STATUS )}
            {Obtain the full data type of an array}
\noteroutine{ARY\_ISACC( IARY, ACCESS, ISACC, STATUS )}
            {Determine whether a specified type of array access is available}
\noteroutine{ARY\_ISMAP( IARY, MAPPED, STATUS )}
            {Determine if an array is currently mapped}
\noteroutine{ARY\_ISBAS( IARY, BASE, STATUS )}
            {Enquire if an array is a base array}
\noteroutine{ARY\_ISTMP( IARY, TEMP, STATUS )}
            {Determine if an array is temporary}
\noteroutine{ARY\_NDIM( IARY, NDIM, STATUS )}
            {Enquire the dimensionality of an array}
\noteroutine{ARY\_OFFS( IARY1, IARY2, MXOFFS, OFFS, STATUS )}
            {Obtain the pixel offset between two arrays}
\noteroutine{ARY\_SAME( IARY1, IARY2, SAME, ISECT, STATUS )}
            {Enquire if two arrays are part of the same base array}
\noteroutine{ARY\_SIZE( IARY, NPIX, STATUS )}
            {Determine the size of an array}
\noteroutine{ARY\_STATE( IARY, STATE, STATUS )}
            {Determine the state of an array (defined or undefined)}
\noteroutine{ARY\_TYPE( IARY, TYPE, STATUS )}
            {Obtain the numeric type of an array}
\noteroutine{ARY\_VALID( IARY, VALID, STATUS )}
            {Determine whether an array identifier is valid}
\noteroutine{ARY\_VERFY( IARY, STATUS )}
            {Verify that an array's data structure is correctly constructed}

\subsection{\xlabel{creating_and_deleting_arrays}Creating and Deleting Arrays}
\label{creating_and_deleting_arrays}

\noteroutine{ARY\_DELET( IARY, STATUS )}
            {Delete an array}
\noteroutine{ARY\_DUPE( IARY1, PLACE, IARY2, STATUS )}
            {Duplicate an array}
\noteroutine{ARY\_NEW( FTYPE, NDIM, LBND, UBND, PLACE, IARY, STATUS )}
            {Create a new simple array}
\noteroutine{ARY\_NEWP( FTYPE, NDIM, UBND, PLACE, IARY, STATUS )}
            {Create a new primitive array}


\subsection{\xlabel{setting_array_attributes}Setting Array Attributes}
\label{setting_array_attributes}

\noteroutine{ARY\_NOACC( ACCESS, IARY, STATUS )}
            {Disable a specified type of access to an array}
\noteroutine{ARY\_RESET( IARY, STATUS )}
            {Reset an array to an undefined state}
\noteroutine{ARY\_SBAD( BAD, IARY, STATUS )}
            {Set the bad-pixel flag for an array}
\noteroutine{ARY\_SHIFT( NSHIFT, SHIFT, IARY, STATUS )}
            {Apply pixel-index shifts to an array}
\noteroutine{ARY\_STYPE( FTYPE, IARY, STATUS )}
            {Set a new type for an array}


\subsection{\xlabel{access_to_array_values}Access to Array Values}
\label{access_to_array_values}

\noteroutine{ARY\_MAP( IARY, TYPE, MMOD, PNTR, EL, STATUS )}
            {Obtain mapped access to an array}
\noteroutine{ARY\_MAPZ( IARY, TYPE, MMOD, RPNTR, IPNTR, EL, STATUS )}
            {Obtain complex mapped access to an array}
\noteroutine{ARY\_UNMAP( IARY, STATUS )}
            {Unmap an array}


\subsection{\xlabel{creation_and_control_of_identifiers}%
Creation and Control of Identifiers}
\label{creation_and_control_of_identifiers}

\noteroutine{ARY\_ANNUL( IARY, STATUS )}
            {Annul an array identifier}
\noteroutine{ARY\_BASE( IARY1, IARY2, STATUS )}
            {Obtain an identifier for a base array}
\noteroutine{ARY\_CLONE( IARY1, IARY2, STATUS )}
            {Clone an array identifier}
\noteroutine{ARY\_SECT( IARY1, NDIM, LBND, UBND, IARY2, STATUS )}
            {Create an array section}
\noteroutine{ARY\_SSECT( IARY1, IARY2, IARY3, STATUS )}
            {Produce a similar array section to an existing one}
\noteroutine{ARY\_VALID( IARY, VALID, STATUS )}
            {Determine whether an array identifier is valid}


\subsection{\xlabel{message_system_routines}Message System Routines}
\label{message_system_routines}

\noteroutine{ARY\_MSG( TOKEN, IARY )}
            {Assign the name of an array to a message token}


\subsection{\xlabel{creating_placeholders}Creating Placeholders}
\label{creating_placeholders}

\noteroutine{ARY\_PLACE( LOC, NAME, PLACE, STATUS )}
            {Obtain an array placeholder}
\noteroutine{ARY\_TEMP( PLACE, STATUS )}
            {Obtain a placeholder for a temporary array}


\subsection{\xlabel{copying_arrays}Copying Arrays}
\label{copying_arrays}

\noteroutine{ARY\_COPY( IARY1, PLACE, IARY2, STATUS )}
            {Copy an array to a new location}
\noteroutine{ARY\_DUPE( IARY1, PLACE, IARY2, STATUS )}
            {Duplicate an array}


\subsection{\xlabel{miscellaneous}Miscellaneous}
\label{miscellaneous}

\noteroutine{ARY\_TRACE( NEWFLG, OLDFLG )}
            {Set the internal ARY\_ system error-tracing flag}

\newpage
\section{\xlabel{routine_descriptions}Routine Descriptions}
\label{routine_descriptions}
\label{ss:routinedescriptions}


\sstroutine{
   ARY\_ANNUL
}{
   Annul an array identifier
}{
   \sstdescription{
      The routine annuls the array identifier supplied so that it is no
      longer recognised as a valid identifier by the ARY\_ routines.
      Any resources associated with it are released and made available
      for re-use. If the array is mapped for access, then it is
      automatically unmapped by this routine.
   }
   \sstinvocation{
      CALL ARY\_ANNUL( IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given and Returned)
      }{
         The array identifier to be annulled. A value of ARY\_\_NOID is
         returned (as defined in the include file ARY\_PAR).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances. In particular, it
         will fail if the identifier supplied is not initially valid, but
         this will only be reported if STATUS is set to SAI\_\_OK on entry.

         \sstitem
         An error will result if an attempt is made to annul the last
         remaining identifier associated with an array which is in an
         undefined state (unless it is a temporary array, in which case it
         will be deleted at this point).
      }
   }
}
\sstroutine{
   ARY\_BAD
}{
   Determine if an array may contain bad pixels
}{
   \sstdescription{
      The routine returns a logical value indicating whether an array
      may contain bad pixels for which checks must be made when its
      values are processed. Only if the returned value is .FALSE. can
      such checks be omitted.  If the CHECK argument to this routine is
      set .TRUE., then it will perform an explicit check (if necessary)
      to see whether bad pixels are actually present.
   }
   \sstinvocation{
      CALL ARY\_BAD( IARY, CHECK, BAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         CHECK = LOGICAL (Given)
      }{
         Whether to perform an explicit check to see if bad pixels are
         actually present.
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         Whether it is necessary to check for bad pixels when processing
         the array\texttt{'}s values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If CHECK is set .FALSE., then the returned value of BAD will
         indicate whether bad pixels might be present and should therefore
         be checked for during subsequent processing. However, even if BAD
         is returned .TRUE. in such circumstances, it is still possible
         that there may not actually be any bad pixels present (for
         instance, in an array section, the region of the base array
         accessed might happen to avoid all the bad pixels).

         \sstitem
         If CHECK is set .TRUE., then an explicit check will be made,
         if necessary, to ensure that BAD is only returned .TRUE. if bad
         pixels are actually present.

         \sstitem
         If the array is mapped for access through the identifier
         supplied, then the value of BAD will refer to the actual mapped
         values. It may differ from its original (unmapped) value if
         conversion errors occurred during the mapping process, or if an
         initialisation option of \texttt{'}/ZERO\texttt{'} was specified for an array which
         was initially undefined, or if the mapped values have subsequently
         been modified.

         \sstitem
         The BAD argument will always return a value of .TRUE. if the
         array is in an undefined state.
      }
   }
}
\sstroutine{
   ARY\_BASE
}{
   Obtain an identifier for a base array
}{
   \sstdescription{
      The routine returns an identifier for the base array with which
      an array section is associated.
   }
   \sstinvocation{
      CALL ARY\_BASE( IARY1, IARY2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         Identifier for an existing array section (the routine will also
         work if this is already a base array).
      }
      \sstsubsection{
         IARY2 = INTEGER (Returned)
      }{
         Identifier for the base array with which the section is
         associated.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_BOUND
}{
   Enquire the pixel-index bounds of an array
}{
   \sstdescription{
      The routine returns the lower and upper pixel-index bounds of
      each dimension of an array, together with the total number of
      dimensions.
   }
   \sstinvocation{
      CALL ARY\_BOUND( IARY, NDIMX, LBND, UBND, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         NDIMX = INTEGER (Given)
      }{
         Maximum number of pixel-index bounds to return (i.e. the
         declared size of the LBND and UBND arguments).
      }
      \sstsubsection{
         LBND( NDIMX ) = INTEGER (Returned)
      }{
         Lower pixel-index bounds for each dimension.
      }
      \sstsubsection{
         UBND( NDIMX ) = INTEGER (Returned)
      }{
         Upper pixel-index bounds for each dimension.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         Total number of array dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the array has fewer than NDIMX dimensions, then any
         remaining elements of the LBND and UBND arguments will be filled
         with 1\texttt{'}s.

         \sstitem
         If the array has more than NDIMX dimensions, then the NDIM
         argument will return the actual number of dimensions. In this
         case only the first NDIMX sets of bounds will be returned, and an
         error will result if the size of any of the remaining dimensions
         exceeds 1.

         \sstitem
         The symbolic constant ARY\_\_MXDIM may be used to declare the
         size of the LBND and UBND arguments so that they will be able to
         hold the maximum number of array bounds that this routine can
         return. This constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_CLONE
}{
   Clone an array identifier
}{
   \sstdescription{
      The routine produces a \texttt{"}cloned\texttt{"} copy of an array identifier (i.e.
      it produces a new identifier describing an array with identical
      attributes to the original).
   }
   \sstinvocation{
      CALL ARY\_CLONE( IARY1, IARY2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         Array identifier to be cloned.
      }
      \sstsubsection{
         IARY2 = INTEGER (Returned)
      }{
         Cloned identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_CMPLX
}{
   Determine whether an array holds complex values
}{
   \sstdescription{
      The routine returns a logical value indicating whether an array
      holds complex values.
   }
   \sstinvocation{
      CALL ARY\_CMPLX( IARY, CMPLX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         CMPLX = LOGICAL (Returned)
      }{
         Whether the array holds complex values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_COPY
}{
   Copy an array to a new location
}{
   \sstdescription{
      The routine copies an array to a new location and returns an
      identifier for the resulting new base array.
   }
   \sstinvocation{
      CALL ARY\_COPY( IARY1, PLACE, IARY2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         Identifier for the array (or array section) to be copied.
      }
      \sstsubsection{
         PLACE = INTEGER (Given and Returned)
      }{
         An array placeholder (e.g. generated by the ARY\_PLACE routine)
         which indicates the position in the data system where the new
         array will reside. The placeholder is annulled by this
         routine, and a value of ARY\_\_NOPL will be returned (as defined
         in the include file ARY\_PAR).
      }
      \sstsubsection{
         IARY2 = INTEGER (Returned)
      }{
         Identifier for the new array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The result of copying a scaled or delta array will be an
         equivalent simple array.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. In either
         event, the placeholder will still be annulled. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_DELET
}{
   Delete an array
}{
   \sstdescription{
      The routine deletes the specified array. If this is a base array,
      then the associated data object is erased and all array
      identifiers which refer to it (or to sections derived from it)
      become invalid. If the array is mapped for access, then it is
      first unmapped.  If an array section is specified, then this
      routine is equivalent to calling ARY\_ANNUL.
   }
   \sstinvocation{
      CALL ARY\_DELET( IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given and Returned)
      }{
         Identifier for the array to be deleted. A value of ARY\_\_NOID
         is returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances.

         \sstitem
         A value of ARY\_\_NOID is always returned for the IARY argument,
         even if the routine should fail. This constant is defined in the
         include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_DELTA
}{
   Compress an array using delta compression
}{
   \sstdescription{
      The routine creates a copy of the supplied array stored in DELTA form,
      which provides a lossless compression scheme for integer data. This
      scheme assumes that adjacent integer values in the input array tend
      to be close in value, and so differences between adjacent values can
      be represented in fewer bits than the absolute values themselves.
      The differences are taken along a nominated pixel axis within the
      supplied array (specified by argument ZAXIS).

      In practice, the scheme is limited currently to representing differences
      between adjacent values using a HDS integer data type (specified by
      argyument TYPE) - that is, arbitrary bit length is not yet supported.
      So for instance an \_INTEGER input array can be compressed by storing
      differences as \_WORD or \_BYTE values, but a \_WORD input array can only
      be compressed by storing differences as \_BYTE values.

      Any input value that differs from its earlier neighbour by more than
      the data range of the selected data type is stored explicitly using
      the data type of the input array.

      Further compression is achieved by replacing runs of equal input values
      by a single occurrence of the value with a correspsonding repetition
      count.

      It should be noted that the degree of compression achieved is
      dependent on the nature of the data, and it is possible for the
      compressed array to occupy more space than the uncompressed array.
      The compression factor actually achieved is returned in argument
      ZRATIO (the ratio of the supplied array size to the compressed
      array size). A minmum allowed compression ratio may be specified via
      argument MINRAT. If the compression ratio is less than this value,
      then the returned copy is left uncompressed.
   }
   \sstinvocation{
      CALL ARY\_DELTA( IARY1, ZAXIS, TYPE, MINRAT, PLACE, ZRATIO, IARY2,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         The input array identifier. This can be stored in any form. If
         it is already stored in DELTA form, it is uncompressed and then
         re-compressed using the supplied compression parameters. If
         is is stored in SCALED form, the internal integer values are
         compressed and the scale and zero terms are copied into the
         DELTA array.
      }
      \sstsubsection{
         ZAXIS = INTEGER (Given)
      }{
         The index of the pixel axis along which differences are to be
         taken. If this is zero, a default value will be selected that
         gives the greatest compression. An error will be reported if a
         value less than zero or greater than the number of axes in the
         input array is supplied.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The data type in which to store the differences between adjacent
         input values. This must be one of \texttt{'}\_BYTE\texttt{'}, \texttt{'}\_WORD\texttt{'} or
         \texttt{'}\_INTEGER\texttt{'}. Additionally, a blank string may be supplied in which
         case a default value will be selected that gives the greatest
         compression.
      }
      \sstsubsection{
         MINRAT = REAL (Given)
      }{
         The minimum allowed ZRATIO value. If compressing the input array
         results in a ZRATIO value smaller than or equal to MINRAT, then
         the returned array is left uncompressed. If the supplied value is
         zero or negative, then the array will be compressed regardless of
         the compression ratio.
      }
      \sstsubsection{
         PLACE = INTEGER (Given and Returned)
      }{
         An array placeholder (e.g. generated by the ARY\_PLACE routine)
         which indicates the position in the data system where the new
         array will reside. The placeholder is annulled by this
         routine, and a value of ARY\_\_NOPL will be returned (as defined
         in the include file ARY\_PAR).
      }
      \sstsubsection{
         ZRATIO = REAL (Returned)
      }{
         The compression factor actually achieved (the ratio of the
         supplied array size to the compressed array size). Genuine
         compressions are represented by values more than 1.0, but values
         less than 1.0 may be returned if the input data is not suited
         to delta compression (i.e. if the \texttt{"}compression\texttt{"} actually expands
         the array storage). Note, the returned value of ZRATIO may be
         smaller than MINRAT, in which case the supplied array is left
         unchanged. The returned compression factor is approximate as it
         does not take into account the space occupied by the HDS metadata
         describing the extra components of a DELTA array (i.e. the
         component names, data types, dimensions, etc). This will only be
         significant for very small arrays.
      }
      \sstsubsection{
         IARY2 = INTEGER (Returned)
      }{
         Identifier for the new DELTA array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         An error will be reported if the supplied array does not hold
         integer values. In the case of a SCALED array, the internal
         (scaled) values must be integers, but the external (unscaled) values
         can be of any data type.

         \sstitem
         The compression axis and compressed data type actually used can
         be determined by passing the returned array to ARY\_GTDLT.

         \sstitem
         An error will result if the array, or any part of it, is
         currently mapped for access (e.g. through another identifier).

         \sstitem
         An error will result if the array holds complex values.
      }
   }
}
\sstroutine{
   ARY\_DIM
}{
   Enquire the dimension sizes of an array
}{
   \sstdescription{
      The routine returns the size in pixels of each dimension of an
      array, together with the total number of dimensions (the size of
      a dimension is the difference between that dimension\texttt{'}s upper and
      lower pixel-index bounds $+$ 1).
   }
   \sstinvocation{
      CALL ARY\_DIM( IARY, NDIMX, DIM, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         NDIMX = INTEGER (Given)
      }{
         Maximum number of dimension sizes to return (i.e. the declared
         size of the DIM argument).
      }
      \sstsubsection{
         DIM( NDIMX ) = INTEGER (Returned)
      }{
         Size of each dimension in pixels.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         Total number of array dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the array has fewer than NDIMX dimensions, then any
         remaining elements of the DIM argument will be filled with 1\texttt{'}s.

         \sstitem
         If the array has more than NDIMX dimensions, then the NDIM
         argument will return the actual number of dimensions. In this
         case only the first NDIMX dimension sizes will be returned, and
         an error will result if the size of any of the excluded
         dimensions exceeds 1.

         \sstitem
         The symbolic constant ARY\_\_MXDIM may be used to declare the
         size of the DIM argument so that it will be able to hold the
         maximum number of array dimension sizes that this routine can
         return. This constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_DUPE
}{
   Duplicate an array
}{
   \sstdescription{
      The routine duplicates an array, creating a new base array with
      the same attributes as an existing array (or array section). The
      new array is left in an undefined state.
   }
   \sstinvocation{
      CALL ARY\_DUPE( IARY1, PLACE, IARY2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         Identifier for the array to be duplicated.
      }
      \sstsubsection{
         PLACE = INTEGER (Given and Returned)
      }{
         An array placeholder (e.g. generated by the ARY\_PLACE routine)
         which indicates the position in the data system where the new
         array will reside. The placeholder is annulled by this
         routine, and a value of ARY\_\_NOPL will be returned (as defined
         in the include file ARY\_PAR).
      }
      \sstsubsection{
         IARY2 = INTEGER (Returned)
      }{
         Identifier for the new duplicate array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Duplicating a scaled or delta array produces and equivalent
         simple array.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason.  In either
         event, the placeholder will still be annulled. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_FIND
}{
   Find an array in an HDS structure and import it into the ARY\_
   system
}{
   \sstdescription{
      The routine finds a named array within an HDS structure, imports
      it into the ARY\_ system and issues an identifier for it. The
      imported array may then be manipulated by the ARY\_ routines.
   }
   \sstinvocation{
      CALL ARY\_FIND( LOC, NAME, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator to the enclosing HDS structure.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the HDS structure component to be imported.
      }
      \sstsubsection{
         IARY = INTEGER (Returned)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_FORM
}{
   Obtain the storage form of an array
}{
   \sstdescription{
      The routine returns the storage form of an array as an upper-case
      character string (e.g. \texttt{'}SIMPLE\texttt{'}).
   }
   \sstinvocation{
      CALL ARY\_FORM( IARY, FORM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         FORM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Storage form of the array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The symbolic constant ARY\_\_SZFRM may be used for declaring the
         length of a character variable to hold the storage form of an
         array. This constant is defined in the include file ARY\_PAR.

         \sstitem
         At present, the ARY\_ routines only support \texttt{"}primitive\texttt{"}, \texttt{"}scaled\texttt{"},
         \texttt{"}simple\texttt{"} and \texttt{"}delta\texttt{"} arrays, so only the values \texttt{'}PRIMITIVE\texttt{'}, \texttt{'}SCALED\texttt{'}
         \texttt{'}DELTA\texttt{'} and \texttt{'}SIMPLE\texttt{'} can be returned.
      }
   }
}
\sstroutine{
   ARY\_FTYPE
}{
   Obtain the full data type of an array
}{
   \sstdescription{
      The routine returns the full data type of an array as an
      upper-case character string (e.g. \texttt{'}\_REAL\texttt{'} or \texttt{'}COMPLEX\_BYTE\texttt{'}).
   }
   \sstinvocation{
      CALL ARY\_FTYPE( IARY, FTYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Full data type of the array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The symbolic constant ARY\_\_SZFTP may be used for declaring the
         length of a character variable to hold the full data type of an
         array. This constant is defined in the include file ARY\_PAR.

         \sstitem
         For \texttt{"}Scaled\texttt{"} arrays, the data type returned by this function is
         the data type of the SCALE and ZERO terms, rather than the data
         type of the stored array.
      }
   }
}
\sstroutine{
   ARY\_GTDLT
}{
   Get the compressed axis and data type for a DELTA array
}{
   \sstdescription{
      The routine returns the details of the compression used to produce
      an array stored in DELTA form. If the array is not stored in
      DELTA form, then null values are returned as listed below, but no
      error is reported.

      A DELTA array is compressed by storing only the differences between
      adjacent array values along a nominated compression axis, rather than
      the full array values. The differences are stored using a smaller data
      type than the original absolute values. The compression is lossless
      because any differences that will not fit into the smaller data type
      are stored explicitly in an extra array with a larger data type.
      Additional compression is achieved by replacing runs of equal values
      by a single value and a repeat count.
   }
   \sstinvocation{
      CALL ARY\_GTDLT( IARY, ZAXIS, ZTYPE, ZRATIO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         ZAXIS = INTEGER (Returned)
      }{
         The index of the pixel axis along which compression occurred.
         The first axis has index 1. Zero is returned if the array is not
         stored in DELTA form.
      }
      \sstsubsection{
         ZTYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The data type in which the differences between adjacent array
         values are stored. This will be one of \texttt{'}\_BYTE\texttt{'}, \texttt{'}\_WORD\texttt{'} or
         \texttt{'}\_INTEGER\texttt{'}. The data type of the array itself is returned if the
         supplid array is not stored in DELTA form.
      }
      \sstsubsection{
         ZRATIO = REAL (Returned)
      }{
         The compression factor - the ratio of the uncompressed array size
         to the compressed array size. This is approximate as it does not
         include the effects of the metadata needed to describe the extra
         components of a DELTA array (i.e. the space needed to hold the
         component names, types, dimensions, etc). A value of 1.0 is
         returned if the supplid array is not stored in DELTA form.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_GTSZB
}{
   Get the scale and zero values for an array
}{
   \sstdescription{
      The routine returns the scale and zero values associated with an array.
      If the array is not stored in scaled form, then values of 1.0 and 0.0
      are returned.
   }
   \sstinvocation{
      CALL ARY\_GTSZB( IARY, SCALE, ZERO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         SCALE = BYTE (Returned)
      }{
         The scaling factor.
      }
      \sstsubsection{
         ZERO = BYTE (Returned)
      }{
         The zero offset.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_IMPRT
}{
   Import an array into the ARY\_ system from HDS
}{
   \sstdescription{
      The routine imports an array into the ARY\_ system from HDS and
      issues an identifier for it. The array may then be manipulated by
      the ARY\_ routines.
   }
   \sstinvocation{
      CALL ARY\_IMPRT( LOC, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         HDS locator to an array structure.
      }
      \sstsubsection{
         IARY = INTEGER (Returned)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The locator supplied as input to this routine may later be
         annulled without affecting the subsequent behaviour of the ARY\_
         system.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_ISACC
}{
   Determine whether a specified type of array access is available
}{
   \sstdescription{
      The routine determines whether a specified type of access to an
      array is available, or whether it has been disabled. If access is
      not available, then any attempt to access the array in this way
      will fail.
   }
   \sstinvocation{
      CALL ARY\_ISACC( IARY, ACCESS, ISACC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         ACCESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type of array access required: \texttt{'}BOUNDS\texttt{'}, \texttt{'}DELETE\texttt{'},
         \texttt{'}SHIFT\texttt{'}, \texttt{'}TYPE\texttt{'} or \texttt{'}WRITE\texttt{'} (see the Notes section for
         details).
      }
      \sstsubsection{
         ISACC = LOGICAL (Returned)
      }{
         Whether the specified type of access is available.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The valid access types control the following operations on the
      array:
      \sstitemlist{

         \sstitem
         \texttt{'}BOUNDS\texttt{'} permits the pixel-index bounds of a base array to be
         altered.

         \sstitem
         \texttt{'}DELETE\texttt{'} permits deletion of the array.

         \sstitem
         \texttt{'}SHIFT\texttt{'} permits pixel-index shifts to be applied to a base
         array.

         \sstitem
         \texttt{'}TYPE\texttt{'} permits the data type of the array to be altered.

         \sstitem
         \texttt{'}WRITE\texttt{'} permits new values to be written to the array, or the
         array\texttt{'}s state to be reset.
      }
   }
}
\sstroutine{
   ARY\_ISBAS
}{
   Enquire if an array is a base array
}{
   \sstdescription{
      The routine returns a logical value indicating whether the array
      whose identifier is supplied is a base array (as opposed to an
      array section).
   }
   \sstinvocation{
      CALL ARY\_ISBAS( IARY, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         BASE = LOGICAL (Returned)
      }{
         Whether the array is a base array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_ISMAP
}{
   Determine if an array is currently mapped
}{
   \sstdescription{
      The routine returns a logical value indicating whether an array is
      currently mapped for access through the identifier supplied.
   }
   \sstinvocation{
      CALL ARY\_ISMAP( IARY, MAPPED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         MAPPED = LOGICAL (Returned)
      }{
         Whether the array is mapped for access through the IARY
         identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_ISTMP
}{
   Determine if an array is temporary
}{
   \sstdescription{
      The routine returns a logical value indicating whether the
      specified array is temporary. Temporary arrays are deleted once
      the last identifier which refers to them is annulled.
   }
   \sstinvocation{
      CALL ARY\_ISTMP( IARY, TEMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         TEMP = LOGICAL (Returned)
      }{
         Whether the array is temporary.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_LOC
}{
   Obtain an HDS locator for an array
}{
   \sstdescription{
      The routine returns an HDS locator for the data object referred to
      by the supplied ARY identifier.
   }
   \sstinvocation{
      CALL ARY\_LOC( IARY, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Returned)
      }{
         The HDS locator. It should be annulled using DAT\_ANNUL when no
         longer needed. A value of DAT\_\_NOLOC will be returned if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_MAP
}{
   Obtain mapped access to an array
}{
   \sstdescription{
      The routine obtains mapped access an array, returning a pointer
      to the mapped values and a count of the number of elements
      mapped.
   }
   \sstinvocation{
      CALL ARY\_MAP( IARY, TYPE, MMOD, PNTR, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The numerical data type required for access (e.g. \texttt{'}\_REAL\texttt{'}).
      }
      \sstsubsection{
         MMOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The mapping mode for access to the array: \texttt{'}READ\texttt{'}, \texttt{'}UPDATE\texttt{'} or
         \texttt{'}WRITE\texttt{'}, with an optional initialisation mode \texttt{'}/BAD\texttt{'} or
         \texttt{'}/ZERO\texttt{'} appended.
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         Pointer to the mapped values.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements mapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the array is a scaled array, the returned mapped values will
         be the stored array values multiplied by the scale factor and shifted
         by the zero term.

         \sstitem
         If the array is a delta (i.e. compressed) array, the returned mapped
         values will be the uncompressed array values.

         \sstitem
         Currently, only READ access is available for scaled and
         compressed arrays. An error will be reported if an attempt is made to
         get WRITE or UPDATE access to a scaled or compressed array.
      }
   }
}
\sstroutine{
   ARY\_MAPZ
}{
   Obtain complex mapped access to an array
}{
   \sstdescription{
      The routine obtains complex mapped access to an array, returning
      pointers to the real and imaginary values and a count of the
      number of elements mapped.
   }
   \sstinvocation{
      CALL ARY\_MAPZ( IARY, TYPE, MMOD, RPNTR, IPNTR, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The numerical data type required for accessing the array (e.g.
         \texttt{'}\_REAL\texttt{'}).
      }
      \sstsubsection{
         MMOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The mapping mode for access to the array: \texttt{'}READ\texttt{'}, \texttt{'}UPDATE\texttt{'} or
         \texttt{'}WRITE\texttt{'}, with an optional initialisation mode \texttt{'}/BAD\texttt{'} or
         \texttt{'}/ZERO\texttt{'} appended.
      }
      \sstsubsection{
         RPNTR = INTEGER (Returned)
      }{
         Pointer to the mapped real (i.e. non-imaginary) values.
      }
      \sstsubsection{
         IPNTR = INTEGER (Returned)
      }{
         Pointer to the mapped imaginary values.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements mapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_MSG
}{
   Assign the name of an array to a message token
}{
   \sstdescription{
      The routine assigns the name of an array to a message token (in a
      form which a user will understand) for use in constructing
      messages with the MSG\_ and ERR\_ routines (see SUN/104).
   }
   \sstinvocation{
      CALL ARY\_MSG( TOKEN, IARY )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine has no STATUS argument and performs no error
         checking. If it should fail, then no assignment to the message
         token will be made and this will be apparent in the final
         message.
      }
   }
}
\sstroutine{
   ARY\_NDIM
}{
   Enquire the dimensionality of an array
}{
   \sstdescription{
      The routine determines the number of dimensions which an array
      has.
   }
   \sstinvocation{
      CALL ARY\_NDIM( IARY, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_NEW
}{
   Create a new simple array
}{
   \sstdescription{
      The routine creates a new simple array and returns an identifier
      for it. The array may subsequently be manipulated with the ARY\_
      routines.
   }
   \sstinvocation{
      CALL ARY\_NEW( FTYPE, NDIM, LBND, UBND, PLACE, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the array.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the array.
      }
      \sstsubsection{
         PLACE = INTEGER (Given and Returned)
      }{
         An array placeholder (e.g. generated by the ARY\_PLACE routine)
         which indicates the position in the data system where the new
         array will reside. The placeholder is annulled by this
         routine, and a value of ARY\_\_NOPL will be returned (as defined
         in the include file ARY\_PAR).
      }
      \sstsubsection{
         IARY = INTEGER (Returned)
      }{
         Identifier for the new array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. In either
         event, the placeholder will still be annulled. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_NEWP
}{
   Create a new primitive array
}{
   \sstdescription{
      The routine creates a new primitive array and returns an
      identifier for it. The array may subsequently be manipulated with
      the ARY\_ routines.
   }
   \sstinvocation{
      CALL ARY\_NEWP( FTYPE, NDIM, UBND, PLACE, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Data type of the array (e.g. \texttt{'}\_REAL\texttt{'}). Note that complex types
         are not allowed for primitive arrays.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the array (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         PLACE = INTEGER (Given and Returned)
      }{
         An array placeholder (e.g. generated by the ARY\_PLACE routine)
         which indicates the position in the data system where the new
         array will reside. The placeholder is annulled by this
         routine, and a value of ARY\_\_NOPL will be returned (as defined
         in the include file ARY\_PAR).
      }
      \sstsubsection{
         IARY = INTEGER (Returned)
      }{
         Identifier for the new array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. In either
         event, the placeholder will still be annulled. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_NOACC
}{
   Disable a specified type of access to an array
}{
   \sstdescription{
      The routine disables the specified type of access to an array, so
      that any subsequent attempt to access it in that way will fail.
      Access restrictions imposed on an array identifier by this
      routine will be propagated to any new identifiers derived from
      it, and cannot be revoked.
   }
   \sstinvocation{
      CALL ARY\_NOACC( ACCESS, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ACCESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type of access to be disabled: \texttt{'}BOUNDS\texttt{'}, \texttt{'}DELETE\texttt{'},
         \texttt{'}MODIFY\texttt{'}, \texttt{'}SCALE\texttt{'}, \texttt{'}SHIFT\texttt{'}, \texttt{'}TYPE\texttt{'} or \texttt{'}WRITE\texttt{'}.
      }
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      Disabling each type of access imposes the following restrictions
      on an array:
      \sstitemlist{

         \sstitem
         \texttt{'}BOUNDS\texttt{'} prevents the pixel-index bounds of a base array from
         being altered.

         \sstitem
         \texttt{'}DELETE\texttt{'} prevents the array being deleted.

         \sstitem
         \texttt{'}MODIFY\texttt{'} prevents any form of modification to the array (i.e.
         it disables all the other access types).

         \sstitem
         \texttt{'}SCALE\texttt{'} prevents the scale and zero values from being changed.

         \sstitem
         \texttt{'}SHIFT\texttt{'} prevents pixel-index shifts from being applied to a
         base array.

         \sstitem
         \texttt{'}TYPE\texttt{'} prevents the data type of the array from being altered.

         \sstitem
         \texttt{'}WRITE\texttt{'} prevents new values from being written to the array,
         or the array\texttt{'}s state from being reset.
      }
   }
}
\sstroutine{
   ARY\_OFFS
}{
   Obtain the pixel offset between two arrays
}{
   \sstdescription{
      The routine returns the pixel offset for each requested dimension
      between two arrays. These values are the offsets which should be
      added to the pixel indices of the first array to obtain the
      indices of the corresponding pixel in the second array.
   }
   \sstinvocation{
      CALL ARY\_OFFS( IARY1, IARY2, MXOFFS, OFFS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         First array identifier.
      }
      \sstsubsection{
         IARY2 = INTEGER (Given)
      }{
         Second array identifier.
      }
      \sstsubsection{
         MXOFFS = INTEGER (Given)
      }{
         Maximum number of pixel offsets to return (i.e. the declared
         size of the OFFS argument).
      }
      \sstsubsection{
         OFFS( MXOFFS ) = INTEGER (Returned)
      }{
         Array of pixel offsets for each dimension.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The two array identifiers supplied need not refer to the same
         base array (although they may often do so). If they do not, then
         the offset between the pixels in each array is determined by
         matching the pixel indices of their respective base arrays.

         \sstitem
         Note that non-zero pixel offsets may exist even for dimensions
         which exceed the dimensionality of either of the two arrays
         supplied. The symbolic constant ARY\_\_MXDIM may be used to declare
         the size of the OFFS argument so that it will be able to hold the
         maximum number of non-zero offsets that this routine can return.
      }
   }
}
\sstroutine{
   ARY\_PLACE
}{
   Obtain an array placeholder
}{
   \sstdescription{
      The routine returns an array placeholder. A placeholder is used
      to identify a position in the underlying data system (HDS) and
      may be passed to other routines (e.g. ARY\_NEW) to indicate where
      a newly created array should be positioned.
   }
   \sstinvocation{
      CALL ARY\_PLACE( LOC, NAME, PLACE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         HDS locator to the structure to contain the new array.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the new structure component (i.e. the array).
      }
      \sstsubsection{
         PLACE = INTEGER (Returned)
      }{
         Array placeholder identifying the nominated position in the
         data system.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Placeholders are intended only for local use within an
         application and only a limited number of them are available
         simultaneously. They are always annulled as soon as they are
         passed to another routine to create a new array, where they are
         effectively exchanged for an array identifier.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOPL will be returned for the PLACE argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOPL
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_PTSZB
}{
   Set new scale and zero values for a scaled array
}{
   \sstdescription{
      The routine sets new values for the scale and zero values
      associated with an array. If the array is stored in simple form,
      then the storage form is changed to scaled.
   }
   \sstinvocation{
      CALL ARY\_PTSZB( IARY, SCALE, ZERO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         SCALE = BYTE (Given)
      }{
         The new value for the scaling factor.
      }
      \sstsubsection{
         ZERO = BYTE (Given)
      }{
         The new value for the zero offset.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine may only be used to change the type of a base
         array. If it is called with an array which is not a base array,
         then it will return without action. No error will result.

         \sstitem
         An error will result if the array, or any part of it, is
         currently mapped for access (e.g. through another identifier).
      }
   }
}
\sstroutine{
   ARY\_RESET
}{
   Reset an array to an undefined state
}{
   \sstdescription{
      The routine resets an array so that its values become undefined.
      Its use is advisable before making format changes to an array if
      retention of the existing values is not required (e.g. before
      changing its data type with the ARY\_STYPE routine); this will
      avoid the cost of converting the existing values.
   }
   \sstinvocation{
      CALL ARY\_RESET( IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine may only be used to reset the state of a base
         array. If an array section is supplied, then it will return
         without action. No error will result.

         \sstitem
         An array cannot be reset while it is mapped for access. This
         routine will fail if this is the case.
      }
   }
}
\sstroutine{
   ARY\_SAME
}{
   Enquire if two arrays are part of the same base array
}{
   \sstdescription{
      The routine determines whether two array identifiers refer to
      parts of the same base array.  If so, it also determines whether
      they intersect.
   }
   \sstinvocation{
      CALL ARY\_SAME( IARY1, IARY2, SAME, ISECT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         Identifier for the first array (or array section).
      }
      \sstsubsection{
         IARY2 = INTEGER (Given)
      }{
         Identifier for the second array (or array section).
      }
      \sstsubsection{
         SAME = LOGICAL (Returned)
      }{
         Whether the identifiers refer to parts of the same base array.
      }
      \sstsubsection{
         ISECT = LOGICAL (Returned)
      }{
         Whether the arrays intersect.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Two arrays (or array sections) are counted as intersecting if
         (i) they both refer to the same base array and (ii) altering
         values in one of the arrays can result in the values in the other
         array changing in consequence.
      }
   }
}
\sstroutine{
   ARY\_SBAD
}{
   Set the bad-pixel flag for an array
}{
   \sstdescription{
      The routine sets the value of the bad-pixel flag for an array. A
      call to this routine with BAD set to .TRUE. declares that the
      specified array may contain bad pixel values for which checks
      must be made by algorithms which subsequently processes its
      values.  A call with BAD set to .FALSE. declares that there are
      definitely no bad values present and that subsequent checks for
      such values may be omitted.
   }
   \sstinvocation{
      CALL ARY\_SBAD( BAD, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Bad-pixel flag value to be set.
      }
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the array is mapped for access when this routine is called,
         then the bad-pixel flag will be associated with the mapped
         values. This information will only be transferred to the actual
         data object when the array is unmapped (but only if it was mapped
         for UPDATE or WRITE access). The value transferred may be
         modified if conversion errors occur during the unmapping process.
      }
   }
}
\sstroutine{
   ARY\_SBND
}{
   Set new pixel-index bounds for an array
}{
   \sstdescription{
      The routine sets new pixel-index bounds for an array (or array
      section). The number of array dimensions may also be changed.  If
      a base array is specified, then a permanent change is made to the
      actual data object and this will be apparent through any other
      array identifiers which refer to it.  However, if an identifier
      for an array section is specified, then its bounds are altered
      without affecting other arrays.
   }
   \sstinvocation{
      CALL ARY\_SBND( NDIM, LBND, UBND, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         New number of array dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         New lower pixel-index bounds of the array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         New upper pixel-index bounds of the array,
      }
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The bounds of an array section cannot be altered while it is
         mapped for access through the identifier supplied to this
         routine.

         \sstitem
         The bounds of a base array cannot be altered while any part of
         it is mapped for access (i.e. even through another identifier).

         \sstitem
         The array\texttt{'}s pixel values (if defined) will be retained for
         those pixels which lie within both the old and new bounds. Any
         pixels lying outside the new bounds will be lost (and cannot
         later be recovered by further changes to the array\texttt{'}s bounds).
         Any new pixels introduced where the new bounds extend beyond the
         old ones will be assigned the \texttt{"}bad\texttt{"} value, and the subsequent
         value of the bad-pixel flag will reflect this.

         \sstitem
         If the bounds of a base array are to be altered and retention
         of the existing pixel values is not required, then a call to
         ARY\_RESET should be made before calling this routine. This will
         eliminate any processing which might otherwise be needed to
         retain the existing values. This step is not necessary with an
         array section, where no processing of pixel values takes place.
      }
   }
}
\sstroutine{
   ARY\_SCTYP
}{
   Obtain the numeric type of a scaled array
}{
   \sstdescription{
      The routine returns the numeric type of a scaled array as an
      upper-case character string (e.g. \texttt{'}\_REAL\texttt{'}). The returned type
      describes the values stored in the array, before they are unscaled
      using the associated scale and zero values. Use ARY\_TYPE if you
      need the data type of the array after it has been unscaled.
   }
   \sstinvocation{
      CALL ARY\_SCTYP( IARY, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Numeric type of the array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the array is not stored in SCALED form, then this routine
         returns the same type as the ARY\_TYPE routine.

         \sstitem
         The symbolic constant ARY\_\_SZTYP may be used for declaring the
         length of a character variable which is to hold the numeric type
         of an array. This constant is defined in the include file
         ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_SECT
}{
   Create an array section
}{
   \sstdescription{
      The routine creates a new array section which refers to a
      selected region of an existing array (or array section). The
      section may be larger or smaller in extent than the original
      array.
   }
   \sstinvocation{
      CALL ARY\_SECT( IARY1, NDIM, LBND, UBND, IARY2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Identifier for the initial array.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions for new section.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds for the new section.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds for the new section.
      }
      \sstsubsection{
         IARY2 = INTEGER (Returned)
      }{
         Identifier for the new section.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The number of section dimensions need not match the number of
         dimensions in the initial array. Pixel-index bounds will be
         padded with 1\texttt{'}s as necessary to identify the pixels to which the
         new section should refer.

         \sstitem
         Note that sections which extend beyond the pixel-index bounds
         of the initial array will be padded with bad pixels.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_SHIFT
}{
   Apply pixel-index shifts to an array
}{
   \sstdescription{
      The routine applies pixel-index shifts to an array. An integer
      shift is applied to each dimension so that its pixel-index
      bounds, and the indices of each pixel, change by the amount of
      shift applied to the corresponding dimension. The array\texttt{'}s pixels
      retain their values and none are lost.
   }
   \sstinvocation{
      CALL ARY\_SHIFT( NSHIFT, SHIFT, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSHIFT = INTEGER (Given)
      }{
         Number of dimensions to which shifts are to be applied. This
         must not exceed the number of array dimensions. If fewer
         shifts are supplied than there are dimensions in the array,
         then the extra dimensions will not be shifted.
      }
      \sstsubsection{
         SHIFT( NSHIFT ) = INTEGER (Given)
      }{
         The pixel-index shifts to be applied to each dimension.
      }
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Pixel-index shifts applied to a base array will affect the
         appearance of that array as seen by all base-array identifiers
         associated with it. However, array sections derived from that
         base array will remain unchanged (as regards both pixel-indices
         and data content).

         \sstitem
         Pixel-index shifts cannot be applied to a base array while any
         part of it is mapped for access (i.e. even through another
         identifier).

         \sstitem
         Pixel-index shifts applied to an array section only affect
         that section itself, and have no effect on other array
         identifiers.

         \sstitem
         Pixel-index shifts cannot be applied to an array section while
         it is mapped for access through the identifier supplied to this
         routine.
      }
   }
}
\sstroutine{
   ARY\_SIZE
}{
   Determine the size of an array
}{
   \sstdescription{
      The routine returns the number of pixels in the array whose
      identifier is supplied (i.e. the product of its dimensions).
   }
   \sstinvocation{
      CALL ARY\_SIZE( IARY, NPIX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         NPIX = INTEGER (Returned)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_SSECT
}{
   Create a similar array section to an existing one
}{
   \sstdescription{
      The routine creates a new array section, using an existing
      section as a template. The new section bears the same
      relationship to its base array as the template section does to
      its own base array. Allowance is made for pixel-index shifts
      which may have been applied so that the pixel-indices of the new
      section match those of the template.  The number of dimensions of
      the input and template arrays may differ.
   }
   \sstinvocation{
      CALL ARY\_SSECT( IARY1, IARY2, IARY3, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY1 = INTEGER (Given)
      }{
         Identifier for the input array from which the section is to be
         derived. This may be a base array or an array section.
      }
      \sstsubsection{
         IARY2 = INTEGER (Given)
      }{
         Identifier for the template section (this may also be a base
         array or an array section).
      }
      \sstsubsection{
         IARY3 = INTEGER (Returned)
      }{
         Identifier for the new array section.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine normally generates an array section.  However, if
         both input arrays are base arrays with identical pixel-index
         bounds, then there is no need to create a section in order to
         access the required part of the first array. In this case a base
         array identifier will be returned instead.

         \sstitem
         The new section created by this routine will have the same
         number of dimensions as the array (or array section) from which
         it is derived. If the template (IARY2) array has fewer dimensions
         than this, then the bounds of any additional input dimensions are
         preserved unchanged in the new array. If the template (IARY2)
         array has more dimensions, then the excess ones are ignored.

         \sstitem
         This routine takes account of the regions of each base array
         to which the input array sections have access. It may therefore
         restrict the region accessible to the new section (and pad with
         \texttt{"}bad\texttt{"} pixels) so as not to grant access to regions of the base
         array which were not previously accessible through the input
         arrays.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOID will be returned for the IARY3 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOID
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_STATE
}{
   Determine the state of an array (defined or undefined)
}{
   \sstdescription{
      The routine returns a logical value indicating whether an array\texttt{'}s
      pixel values are currently defined.
   }
   \sstinvocation{
      CALL ARY\_STATE( IARY, STATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATE = LOGICAL (Returned)
      }{
         Whether the array\texttt{'}s pixel values are defined.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_STYPE
}{
   Set a new type for an array
}{
   \sstdescription{
      The routine sets a new full type for an array, causing its data
      storage type to be changed. If the array\texttt{'}s pixel values are
      defined, then they will be converted from the old type to the new
      one.  If they are undefined, then no conversion will be
      necessary.  Subsequent enquiries will reflect the new type.
      Conversion may be performed between any types supported by the
      ARY\_ routines, including from a non-complex type to a complex
      type (and vice versa).
   }
   \sstinvocation{
      CALL ARY\_STYPE( FTYPE, IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The new full type specification for the array (e.g.  \texttt{'}\_REAL\texttt{'}
         or \texttt{'}COMPLEX\_INTEGER\texttt{'}).
      }
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine may only be used to change the type of a base
         array. If it is called with an array which is not a base array,
         then it will return without action. No error will result.

         \sstitem
         An error will result if the array, or any part of it, is
         currently mapped for access (e.g. through another identifier).

         \sstitem
         If the type of an array is to be changed without its pixel
         values being retained, then a call to ARY\_RESET should be made
         beforehand. This will avoid the cost of converting all the
         values.
      }
   }
}
\sstroutine{
   ARY\_TEMP
}{
   Obtain a placeholder for a temporary array
}{
   \sstdescription{
      The routine returns an array placeholder which may be used to
      create a temporary array (i.e. one which will be deleted
      automatically once the last identifier associated with it is
      annulled). The placeholder returned by this routine may be passed
      to other routines (e.g. ARY\_NEW or ARY\_COPY) to produce a
      temporary array in the same way as a new permanent array would be
      created.
   }
   \sstinvocation{
      CALL ARY\_TEMP( PLACE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PLACE = INTEGER (Returned)
      }{
         Placeholder for a temporary array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Placeholders are intended only for local use within an
         application and only a limited number of them are available
         simultaneously. They are always annulled as soon as they are
         passed to another routine to create a new array, where they are
         effectively exchanged for an array identifier.

         \sstitem
         If this routine is called with STATUS set, then a value of
         ARY\_\_NOPL will be returned for the PLACE argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The ARY\_\_NOPL
         constant is defined in the include file ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_TRACE
}{
   Set the internal ARY\_ system error-tracing flag
}{
   \sstdescription{
      The routine sets an internal flag in the ARY\_ system which
      enables or disables error-tracing messages. If this flag is set
      to .TRUE., then any error occurring within the ARY\_ system will
      be accompanied by error messages indicating which internal
      routines have exited prematurely as a result. If the flag is set
      to .FALSE., this internal diagnostic information will not appear
      and only standard error messages will be produced.
   }
   \sstinvocation{
      CALL ARY\_TRACE( NEWFLG, OLDFLG )
   }
   \sstarguments{
      \sstsubsection{
         NEWFLG = LOGICAL (Given)
      }{
         The new value to be set for the error-tracing flag.
      }
      \sstsubsection{
         OLDFLG = LOGICAL (Returned)
      }{
         The previous value of the flag.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         By default, the error tracing flag is set to .FALSE., so
         no internal diagnostic information will be produced.
      }
   }
}
\sstroutine{
   ARY\_TYPE
}{
   Obtain the numeric type of an array
}{
   \sstdescription{
      The routine returns the numeric type of an array as an upper-case
      character string (e.g. \texttt{'}\_REAL\texttt{'}).
   }
   \sstinvocation{
      CALL ARY\_TYPE( IARY, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Numeric type of the array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The symbolic constant ARY\_\_SZTYP may be used for declaring the
         length of a character variable which is to hold the numeric type
         of an array. This constant is defined in the include file
         ARY\_PAR.
      }
   }
}
\sstroutine{
   ARY\_UNMAP
}{
   Unmap an array
}{
   \sstdescription{
      The routine unmaps an array which has previously been mapped for
      READ, UPDATE or WRITE access.
   }
   \sstinvocation{
      CALL ARY\_UNMAP( IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry, although no further error report will be made if it
         subsequently fails under these circumstances.

         \sstitem
         An error will result if the array has not previously been
         mapped for access.
      }
   }
}
\sstroutine{
   ARY\_VALID
}{
   Determine whether an array identifier is valid
}{
   \sstdescription{
      Determine whether an array identifier is valid (i.e. associated
      with an array).
   }
   \sstinvocation{
      CALL ARY\_VALID( IARY, VALID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Identifier to be tested.
      }
      \sstsubsection{
         VALID = LOGICAL (Returned)
      }{
         Whether the identifier is valid.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARY\_VERFY
}{
   Verify that an array\texttt{'}s data structure is correctly constructed
}{
   \sstdescription{
      The routine checks that the data structure containing an array is
      correctly constructed and that the array\texttt{'}s pixel values are
      defined. It also checks for the presence of any \texttt{"}rogue\texttt{"}
      components in the data structure. If an anomaly is found, then an
      error results. Otherwise, the routine returns without further
      action.
   }
   \sstinvocation{
      CALL ARY\_VERFY( IARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IARY = INTEGER (Given)
      }{
         Array identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\newpage
\section{\xlabel{changes_and_new_features_in_v11}%
Changes and new features in V1.1}
\label{changes_and_new_features_in_v11}

Only relatively minor changes have taken place since the previous
version (V1.0) of the ARY\_ system.  The most significant of these are
as follows:

\begin{enumerate}

\item An obscure bug resulting from an un-annulled HDS locator has been
fixed.  This could occasionally result in corrupted files if the
ARY\_STYPE routine was called repeatedly from successive invocations of
an application in an ADAM monolith.

\item Two new routines have been introduced, primarily to provide facilities
required by the NDF\_ system:

\begin{itemize}

\item \noteroutine{ARY\_NDIM( IARY, NDIM, STATUS )}
                  {Enquire the dimensionality of an array}

\item \noteroutine{ARY\_OFFS( IARY1, IARY2, MXOFFS, OFFS, STATUS )}
                  {Obtain the pixel offset between two arrays}

\end{itemize}

\item A stand-alone (non-ADAM) version of the ARY\_ library has been
added and new linker options files have been provided to allow linking
with either version.

\item The encoding of ARY\_ system identifiers has been changed to
improve the chance of detecting erroneous identifier values.

\item Messages about array data structures now contain the full HDS object
name, including the full container file name.

\item A few minor documentation errors have been corrected.

\end{enumerate}

No changes to existing applications should be required, neither should any
re-compilation or re-linking be necessary.

\section{\xlabel{changes_and_new_features_in_v13}%
Changes and new features in V1.3}
\label{changes_and_new_features_in_v13}
The most significant changes in version (V1.3) of the ARY\_ system were
as follows:

\begin{enumerate}

\item A new array storage form called ``DELTA'' has been introduced. This
provides lossless compression for integer arrays. The new routine
ARY\_DELTA creates a copy of a supplied array, stored in DELTA form.

\item A new routine called ARY\_LOC returns a locator for the
HDS data object referred to by the supplied ARY identifier.

\end{enumerate}

\section{\xlabel{changes_and_new_features_in_v14}%
Changes and new features in V1.4}
\label{changes_and_new_features_in_v14}
The most significant changes in version (V1.4) of the ARY\_ system are
as follows:

\begin{enumerate}

\item A bug in ARY\_DUPE has been fixed. This bug resulted in the wrong data
type for the output array if the input array was compressed.

\end{enumerate}

No changes to existing applications should be required, neither should any
re-compilation or re-linking be necessary (so long as you do not need to
use any of the new features of course).

% ? End of main text
\end{document}

